#!/usr/bin/env node
/**
 * Migration Runner
 *
 * Runs database migrations organized by feature module.
 *
 * Usage:
 *   node scripts/migrate.js                    # Apply all pending migrations
 *   node scripts/migrate.js --feature=tasks    # Apply only tasks migrations
 *   node scripts/migrate.js --list             # List all migrations and their status
 *   node scripts/migrate.js --rollback=tasks   # Rollback last migration for a feature
 *
 * @see https://github.com/mejohnc-ft/MeJohnC.Org/issues/107
 */

const fs = require('fs');
const path = require('path');

// Configuration
const MIGRATIONS_DIR = path.join(__dirname, '..', 'supabase', 'migrations');

// Feature module order (dependencies first)
const FEATURE_ORDER = [
  'core',           // Base tables, RLS functions
  'bookmarks',      // No dependencies
  'news',           // No dependencies
  'tasks',          // No dependencies
  'crm',            // No dependencies
  'marketing',      // May depend on CRM
  'metrics',        // No dependencies
  'style-guide',    // No dependencies
  'site-builder',   // No dependencies
  'generative-ui',  // May depend on style-guide, metrics
];

/**
 * Get all migration files for a feature
 */
function getFeatureMigrations(feature) {
  const featureDir = path.join(MIGRATIONS_DIR, feature);

  if (!fs.existsSync(featureDir)) {
    return [];
  }

  const files = fs.readdirSync(featureDir)
    .filter(f => f.endsWith('.sql'))
    .sort(); // Sort by version number (001_, 002_, etc.)

  return files.map(file => ({
    feature,
    file,
    path: path.join(featureDir, file),
    version: parseInt(file.split('_')[0], 10),
  }));
}

/**
 * Get all migrations in dependency order
 */
function getAllMigrations() {
  const migrations = [];

  for (const feature of FEATURE_ORDER) {
    migrations.push(...getFeatureMigrations(feature));
  }

  return migrations;
}

/**
 * List all migrations and their status
 */
function listMigrations() {
  console.log('\nðŸ“‹ Database Migrations\n');
  console.log('Feature directories:', FEATURE_ORDER.join(', '));
  console.log('');

  for (const feature of FEATURE_ORDER) {
    const migrations = getFeatureMigrations(feature);
    const featureDir = path.join(MIGRATIONS_DIR, feature);
    const exists = fs.existsSync(featureDir);

    if (!exists) {
      console.log(`âŒ ${feature}/ - directory not found`);
    } else if (migrations.length === 0) {
      console.log(`ðŸ“ ${feature}/ - no migrations yet`);
    } else {
      console.log(`âœ… ${feature}/ - ${migrations.length} migration(s)`);
      for (const m of migrations) {
        console.log(`   â””â”€â”€ ${m.file}`);
      }
    }
  }

  // Also list legacy migrations
  console.log('\nðŸ“¦ Legacy Migrations (root level):');
  const legacyFiles = fs.readdirSync(MIGRATIONS_DIR)
    .filter(f => f.endsWith('.sql') && !FEATURE_ORDER.includes(f.replace('.sql', '')));

  for (const file of legacyFiles) {
    console.log(`   â””â”€â”€ ${file}`);
  }

  console.log('\n');
}

/**
 * Generate SQL to apply migrations
 */
function generateApplySQL(migrations) {
  let sql = '-- Migration batch generated by migrate.js\n';
  sql += `-- Generated at: ${new Date().toISOString()}\n\n`;

  for (const m of migrations) {
    sql += `-- ========================================\n`;
    sql += `-- Feature: ${m.feature}\n`;
    sql += `-- File: ${m.file}\n`;
    sql += `-- ========================================\n\n`;

    const content = fs.readFileSync(m.path, 'utf-8');
    sql += content;
    sql += '\n\n';
  }

  return sql;
}

/**
 * Main CLI handler
 */
function main() {
  const args = process.argv.slice(2);

  if (args.includes('--list') || args.includes('-l')) {
    listMigrations();
    return;
  }

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
Migration Runner - Organize and apply database migrations by feature.

Usage:
  node scripts/migrate.js                    Apply all pending migrations
  node scripts/migrate.js --feature=<name>   Apply migrations for a specific feature
  node scripts/migrate.js --list             List all migrations
  node scripts/migrate.js --generate         Generate combined SQL file
  node scripts/migrate.js --help             Show this help

Features: ${FEATURE_ORDER.join(', ')}

Migration files should be named: {version}_{description}.sql
Example: 001_initial.sql, 002_add_indexes.sql
`);
    return;
  }

  const featureArg = args.find(a => a.startsWith('--feature='));
  const feature = featureArg ? featureArg.split('=')[1] : null;

  if (feature && !FEATURE_ORDER.includes(feature)) {
    console.error(`Unknown feature: ${feature}`);
    console.error(`Valid features: ${FEATURE_ORDER.join(', ')}`);
    process.exit(1);
  }

  let migrations;
  if (feature) {
    migrations = getFeatureMigrations(feature);
    console.log(`\nðŸŽ¯ Migrations for feature: ${feature}\n`);
  } else {
    migrations = getAllMigrations();
    console.log('\nðŸš€ All Migrations\n');
  }

  if (migrations.length === 0) {
    console.log('No migrations found.\n');
    return;
  }

  console.log(`Found ${migrations.length} migration(s):\n`);
  for (const m of migrations) {
    console.log(`  [${m.feature}] ${m.file}`);
  }

  if (args.includes('--generate')) {
    const sql = generateApplySQL(migrations);
    const outputFile = path.join(MIGRATIONS_DIR, `_generated_${Date.now()}.sql`);
    fs.writeFileSync(outputFile, sql);
    console.log(`\nâœ… Generated: ${outputFile}\n`);
  } else {
    console.log('\nTo apply these migrations:');
    console.log('1. Copy the SQL files to Supabase SQL Editor');
    console.log('2. Or use: node scripts/migrate.js --generate');
    console.log('');
  }
}

main();
